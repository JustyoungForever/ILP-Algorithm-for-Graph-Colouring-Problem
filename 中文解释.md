
```bash
python3 main.py --algo iterlp2 --time 60 --seed 0 \
  --init-heuristic smallest_last \
  --fix-policy prefix_shrink+rounded_support \
  --max-fix-per-round 20 \
  --restarts 48 --perturb-y 1e-6
```

---

# MAIN（入口调度）

```text
Function MAIN(args)  // 主入口：解析参数→准备图→按选择执行算法，打印汇总
  G ← LOAD_GRAPH(args.seed)  
  // 载入或生成测试图；seed 影响随机性，便于复现实验。

  if args.algo == "dsatur" then  
    // 如果只跑基线（不进 LP），便于和主算法做对照。
    col ← DSATUR(G)  
    // 经典贪心着色器：按饱和度顺序给点染色，得到一个可行解。
    PRINT(VERIFY(G, col), used=|colors(col)|)  
    // 验证解是否无冲突并打印用色数（作为 UB 基线）。
  else  // iterlp2  
    // 否则进入我们的“迭代 LP + 舍入 + 修补”的主流程。
    base ← DSATUR(G)  
    // 先跑一次 DSATUR，得到一个可行上界 UB（对照用）。
    PRINT(VERIFY(G, base), used=|colors(base)|)  
    // 打印基线质量，便于后续比对算法改进幅度。

    res  ← ITER_LP_V2(G, time_limit=args.time,      //跑多久
                         init_heuristic=args.init_heuristic,        //第一步用什么方式来确定初解,UB和K
                         fix_policy=args.fix_policy,            //从x_*和y_*中挑选固化
                         restarts=args.restarts,    //对于分数解，尝试多少次舍入
                         perturb_y=args.perturb_y,  //对颜色的优先级加入多少扰动，来避免相同的重复
                         max_fix_per_round=args.max_fix_per_round       //每一轮最多固定几个顶点，避免LP被锁死
                         )
    // 调用核心算法。只传必要的“策略型”参数；具体计算细节在库函数内部完成。

    PRINT(res.summary)  
    // 打印最终 UB/LB、停止原因（达到最优/停滞/超时），便于快速判断运行是否成功。
End
```

---

# ITERLP2（核心迭代 LP v2）

```text
Algorithm ITER_LP_V2(G, time_limit, init_heuristic, fix_policy, restarts, perturb_y, max_fix_per_round)

  LB ← CLIQUE_LOWER_BOUND(G)  
  // 用一个（快速的）团枚举近似获得下界。理由：团中点必须两两不同色，因此 |Q| 是合法下界。

  col0 ← (init_heuristic == "smallest_last" ? SMALLEST_LAST(G) : DSATUR(G))  
  // 生成初解：Smallest-Last 在稀疏图常比 DSATUR 更紧
  UB  ← |colors(COMPACT(col0))|  
  // 将颜色编号压紧到 0..k-1 再计数，得到“当前最好可行上界”。压紧可减少后续整理成本。
  K   ← UB  
  // 让 LP “允许颜色槽位”的前缀 K 与当前 UB 对齐。理由：先别比现有解更紧，避免一上来就 infeasible。

  if UB ≤ LB then return RESULT(UB, LB, col0, stop="UB==LB")  
  // 如果上界已等于下界，说明已经最优，无需进入 LP 循环。

  INC ← BUILD_INCREMENTAL_LP(G, colors=0..UB-1, with_precedence=True, with_clique_cuts=True)  
  // 一次性构建 LP：变量 x[v,c]、y[c]；目标 min Σ y[c]；基本约束+团切面与先后约束。
  // “增量”含义：后续只改变量上下界（锁前缀、固定 x），不重新建模。

  while time_remaining(time_limit) do  
    // 主循环：只要没超时就继续。这样能在固定时间预算内尽可能改善 UB。

    (zLP, x*, y*) ← INC.SOLVE()  
    // 解 LP 得分数解。zLP 是 LP 对 χ(G) 的下界；x*, y* 提供“往哪个颜色靠近”的偏好。

    if ceil(zLP) < K then  
      // LP 得到“理论上至少需要 ceil(zLP) 个颜色”，
      //       如果比当前允许的 K 更少，就尝试收紧搜索空间。
      K_target ← max(LB, ceil(zLP))  
      // 绝不把 K 收到 LB 以下，否则连理论下界都不满足。
      if INC.TRY_APPLY_AND_SOLVE(LOCK_PREFIX(K_target)) == ok then  
        // 实施“锁前缀”：把 y[c]=0（c≥K_target），并立即重解 LP 验证是否仍可行。
        // 成功才接受，避免把模型锁死到不可行区域。
        K ← K_target  
      else
        INC.REVERT()  
        // 回滚锁定；理由：“只要不可行就撤销”，保持循环稳定可继续前进。

    cand ← ROUND_AND_REPAIR_MULTI(G, x*, y*, K, restarts, perturb_y)  
    // 舍入+修补（多启动）：利用 x*/y* 的偏好先试“好染法”，不行再用 Kempe/小修补补洞。
    // 目的：从分数解快速构造“真实可行解”（整数着色），期望用色 ≤ K。

    if VERIFY(G, cand, allowed=0..K-1) == feasible then  
      // 如果舍入成功（不冲突、颜色不越界），我们尝试“把高编号颜色往前挤”以进一步减色。
      cand ← CONSOLIDATE_COLORS(G, coloring, passes) 
      //input:
              G: graph;
              cloring: 当前整数染色;
              passes:尝试“压色”的轮数（默认 10）
      //output:
             new_coloring, reduced:  新的染色 + 是否减少了颜色数（True/False）
      //尽量把最高颜色层（比如颜色 k-1）的顶点重涂进较低颜色 {0,…,k-2},实用的方法是greedy + kempe chain
      //如果这一层被搬空了，就重编号（把用到的颜色重新映射为 0..k'-1），
        //算一次“减色成功”。重复这件事至多 passes 轮。
      // 原因：有些颜色只剩少数点，可能能合并掉一个色。

      //clors(cand)：表示“当前染色 cand 实际用到的颜色集合”（例如 {0,1,3}）
      //|colors(cand)|: 是用到的不同颜色的数量（上面这个例子是3）
      //best_coloring是当前最优可行解的着色映射

      if |colors(cand)| < UB then  
        // 真正的进步：上界变小。只有这类改进才算“实质进展”。
        UB ← |colors(cand)|; 
        best_coloring ← cand；

        if K > UB and LP 仍然能在“仅用前 UB 种颜色”的前提下找到可行最优的分数解 then  
          // 若 LP 还允许更多颜色，就把 K 同步到新的 UB，保证“前缀一致”利于下一轮约束收紧。
          K ← UB
        if UB ≤ LB then return RESULT(UB, LB, best_coloring, stop="UB==LB")  
        // 一旦上界碰到下界，理论+构造都达成：证明最优，直接返回。

    else  
      // 舍入失败：说明当前 K 的前缀内很难一次到位。此时做“侧向探索”，避免陷入局部困境。
      if (K+1) < UB then  
        // 只在“多 1 种颜色（K+1）严格好于当前 UB”时才尝试，如果 K+1 > UB（也就是“放宽”的颜色数已经不比当前上界更紧），直接跳过这条支路。

        (ok1, cand1) ← TRY_SIDE_ROUNDING(G, x*, y*, target_UB=K+1, restarts, perturb_y) 
        // TRY_SIDE_ROUNDING ：用 K+1 做一轮round & repair（multi-start）
        //这里的restars = max(4, restarts//2)，考虑到我的restarts = 16，所以比之前的R &R 要节省资源。


        if ok1 and |colors(cand1)| < UB then  
          // 如果这条支路直接给出更小的 UB，当然接受。
          UB ← |colors(cand1)|; best_coloring ← cand1
          if UB ≤ LB then return RESULT(UB, LB, best_coloring, stop="UB==LB")

      if (UB-1) ≥ LB then  
        // 也可反向“减 1 色”（UB-1）试探是否已经够用。仅在不低于 LB 时尝试，避免违反下界。
        (ok2, cand2) ← TRY_SIDE_ROUNDING(G, x*, y*, target_UB=UB-1, restarts, perturb_y)
        if ok2 and |colors(cand2)| < UB then
          UB ← |colors(cand2)|; best_coloring ← cand2
          if UB ≤ LB then return RESULT(UB, LB, best_coloring, stop="UB==LB")

    if UB == K+1 then  
      // 重要“窗口”触发器：当 UB 比 K 只大 1 时，说明 LP 已很紧，只差“把最高色塞回前缀”。
      (ok_pack, col_pack) ← TRY_LP_GUIDED_PACK(G, best_coloring, x*, K, UB)  
      // 用 LP 的 x* 指引把最高颜色（UB-1）中的点优先塞向“对它们最友好”的前缀颜色。
      //TRY_LP_GUIDED_PACK:
          1. 令 K 为最高颜色层；尝试把 所有 color==K 的顶点 迁移到 0..K-1 里的某个颜色中
          2. 迁移的目标颜色顺序由 LP 的 x_frac 决定：对每个顶点 v，按 x_frac[(v,c)] 从大到小排列 c in {0..K-1}，优先把 v 塞向它 LP 最偏好的前缀颜色。
      //具体思路：
      //对当前仍然在颜色K的每个顶点v:
      //  a.1:生成 targets = sort_{c in 0..K-1} x_frac[(v,c)]（降序）
      //  a.2: 先贪心尝试把 v 改涂为某个 c in targets 且不与邻居冲突;
                如果不行，再在 {c_now=K, c_target} 两色子图上做 Kempe 链交换
      // b:若清空成功：立刻紧凑重编号（把用到的颜色重新映射成 0..k-1

      if ok_pack and |colors(col_pack)| < UB then
        UB ← |colors(col_pack)|; best_coloring ← col_pack
        if K > UB then (try sync K→UB via LOCK_PREFIX)  
        if UB ≤ LB then return RESULT(UB, LB, best_coloring, stop="UB==LB")

      (ok_g,  col_g) ← TRY_GRAPH_UB1_GREEDY(G, best_coloring, UB)  
      // 再试一次整个图的 UB-1 贪心/Kempe：不依赖 LP，能补齐 LP 引导失效的情况。
      if ok_g and |colors(col_g)| < UB then
        UB ← |colors(col_g)|; best_coloring ← col_g
        if K > UB then (try sync K→UB via LOCK_PREFIX)
        if UB ≤ LB then return RESULT(UB, LB, best_coloring, stop="UB==LB")

    //基于 LP 的分数解 (z_LP, x_frac, y_frac) 和当前颜色预算 UB(=K)，保守地挑选一小批“安全的固定”，返回一个计划
    //用少量高置信度的固定来稳定后续 LP 与舍入，避免解空间过度抖动。

    /* plan = {
          "y_zero": [要锁为0的颜色c列表],      # 缩前缀：把 y_c=0（c≥K_new）
          "x_one":  [(v,c) 列表],               # 强指派：把 x[v,c]=1（并令 v 的其它颜色=0）
          "x_zero": [(v,c) 列表],               #（通常为空，本实现基本不启用）
      }
    */
    //应用x_one后尝试重新求 LP；若可解，再跑一小轮 R&R，看看 UB 能否下降

    //   x* ：LP 的顶点-颜色分数 (v,c)↦[0,1]，表示“v 用 c”的倾向；
    //   y*：LP 的颜色启用分数 c↦[0,1]；（本函数里主要用于统计/可选策略）；
    //   zLP：当前 LP 目标值/下界，用于 ceil(zLP) 推断最少需要的颜色数；
    //   UB=K：当前允许的颜色前缀大小（可用颜色为 0..K-1）；
    //   LB ：下界（例如团下界），收紧前缀时不得低于 LB；
    //   policy ：策略组合字符串（如 "prefix_shrink+strong_assign+rounded_support"）；
    //   max_fix_per_round ：本轮最多固定多少个 (v,c)，防止一次锁太多；
    //   support_from_round=cand：最近一次舍入得到的整数染色，用于“与舍入一致”的筛选。

    plan ← PICK_FIXINGS(x*, y*, zLP, UB=K, LB, policy=fix_policy,
                        max_fix_per_round=max_fix_per_round, support_from_round=cand)
    //每一轮在此之前都重解 LP，很多顶点在两三个颜色之间分数很接近，舍入的时候这一轮选 A、下轮又选 B，来回摇摆 → 后续 LP/舍入也跟着变，难以收敛、也难以把颜色压下去。
    //所以把那些 x[v,c] 对某个颜色 明显高于第二名、并且与上一轮舍入一致 的顶点固定为 x[v,c]=1（其余颜色=0）。
    //即先对每个顶点 v，在颜色域 0..UB-1 上找到第一名 (c1, v1) 和第二名值 v2；
        若 v1 - v2 ≥ strong_margin（默认 0.25），
        就把 (v, c1) 加入 plan["x_one"]
    //一次只固定 max_fix_per_round 个，避免把模型锁死,若 LP 不可行就立刻回滚。
    // 目的：减少解空间抖动，稳定后续的 LP 与舍入；严格限额避免把模型锁死。

    if plan.x_one ≠ ∅ then
      if INC.TRY_APPLY_AND_SOLVE(FIX_X_ON(plan.x_one where color<K)) == ok then
        // 只固定前缀颜色 K 内的变量，保证不与“锁前缀”策略冲突。
        cand3 ← ROUND_AND_REPAIR_MULTI(G, INC.x*, INC.y*, K, max(2, ⌊restarts/2⌋), perturb_y)
        // 固定之后再来一次 R&R（次数可少一点）；若成功且更好就更新 UB。
        
        if VERIFY(G, cand3, allowed=0..K-1) == feasible and |colors(COMPACT(cand3))| < UB then
          UB ← |colors(COMPACT(cand3))|; best_coloring ← COMPACT(cand3)
          if K > UB then (try sync K→UB via LOCK_PREFIX)
          if UB ≤ LB then return RESULT(UB, LB, best_coloring, stop="UB==LB")
      else
        INC.REVERT()  
        // 固定导致 LP 不可行就立刻回滚，保持循环进行。

    if ceil(zLP) ≥ UB and K ≤ UB then  
      // 终止判据 1：LP 下界已经不小于上界，且允许集 K 不比 UB 小——继续下去几乎不可能改进。
      return RESULT(UB, LB, best_coloring, stop="no_better_than_UB")

    if STALLING_AT_FIXED_K() then  
      // 终止判据 2：在 K 已与 ceil(zLP) 对齐时，若若干轮没有“收紧K/固定/降UB”的实质进展，则认为停滞。
      return RESULT(UB, LB, best_coloring, stop="stalled")

  end while

  return RESULT(UB, LB, best_coloring, stop="time_limit")  
  // 终止判据 3：超时（可控、可复现实验时长）。
End
```

---

# INCREMENTAL_LP（一次建模，多次改界）

```text
Class INCREMENTAL_LP
  State:
    solver                        // 线性规划求解器
    X[v,c] ∈ [0,1]                // 顶点-颜色分配变量（LP 放松，提供分数指引）
    Y[c] ∈ [0,1]                  // 颜色启用变量（LP 放松，用来控制“颜色槽位”）
    bounds_stack                  // 回滚用：记录被修改变量的旧上下界

  Method BUILD(G, allowed_colors, root_clique, extra_cliques, add_precedence)
    创建变量 X, Y，并设置目标 min Σ_c Y[c]                  // 目标：最少启用颜色（LP 下界）
    对每个 v 加入 Σ_c X[v,c] = 1                           // 每个顶点必须恰好一种颜色（可分数）
    对每条边 (u,v) 与每个 c 加入 X[u,c] + X[v,c] ≤ Y[c]      // **ASS-S 风格**：同色容量受 Y[c] 控制；
                                                             // 当锁前缀把某些 Y[c]=0 时，该颜色在全图被禁用
    对每个 (v,c) 加入 X[v,c] ≤ Y[c]                          // 连接约束（更紧的放松）：顶点用色不能超过色启用度
    对每个颜色 c 加入 Y[c] ≤ Σ_v X[v,c]                      // **ASS 扩展**：禁止“空色”（Y>0 却没人用）
    对 root_clique 与 extra_cliques 加强团不等式              // 团切面：Σ_{v∈Q} X[v,c] ≤ 1，强化下界
    若 add_precedence：对 c=0..K-2 加入 Y[c+1] ≤ Y[c]          // 去对称：颜色按前缀次序启用，便于收敛与锁前缀
    返回 self                                                 // 返回增量器：后续只改上下界并可回滚

  Method SOLVE()
    调用 solver.Solve()，提取 zLP, x_frac, y_frac             // 求 LP，得到下界与分数解
    返回 (zLP, x_frac, y_frac)                                 // y_frac 常为小数：用于颜色优先级

  Method LOCK_PREFIX_K(K_target)
    生成 token 并把所有 c ≥ K_target 的 Y[c] 设为 0           // 锁前缀：收紧允许颜色集到 0..K_target-1
    返回 token                                                 // 与回滚/试解配合，失败即时撤销

  Method FIX_VERTEX_COLOR(v,c)
    生成 token，把 X[v,c]=1，且 X[v,c'≠c]=0                    // 固定一个顶点的颜色，稳定后续舍入/LP
    返回 token

  Method TRY_APPLY_AND_SOLVE(token or tokens[])
    应用这些上下界修改并尝试求解                             // 成功则返回新 (zLP,x*,y*)，失败则交由调用者回滚
    返回 (info, ok)

  Method REVERT(token or tokens[])
    用 token 记录的旧界逐项恢复                               // 严格可逆，保证迭代探索的安全性
    丢弃 token
End

```

---

# LP 模型（构建细节）

```text
Function BUILD_ASSIGNMENT_LP(G, K, cliques, with_precedence)
  创建变量：X[v,c] ∈ [0,1]，Y[c] ∈ [0,1]                     // LP 放松，便于得到分数指引
  目标：minimize Σ_{c=0}^{K-1} Y[c]                           // 以最少启用颜色为目标（χ(G) 的下界）

  约束：∀v, Σ_c X[v,c] = 1                                   // 每个顶点恰好一种颜色
  约束：∀(u,v)∈E, ∀c, X[u,c] + X[v,c] ≤ Y[c]                  // 当 Y[c]=0 时同色完全禁止；与锁前缀自然协同
  约束：∀v,c, X[v,c] ≤ Y[c]                                  // 连接约束（保留）：让 LP 更紧，x 受 y 夹制
  约束：∀c,   Y[c] ≤ Σ_{v∈V} X[v,c]                          // **新增**：禁止“空色”，避免 y 被虚假拉低
  团切面：∀Q∈cliques, ∀c, Σ_{v∈Q} X[v,c] ≤ 1                  // 选取若干团加强 LP 下界（可选但推荐）
  若 with_precedence：∀c=0..K-2, Y[c+1] ≤ Y[c]                // 前缀启用次序，去对称，便于 K 的逐步收紧

  返回 (solver, X, Y)
End

```

---

# ROUND_AND_REPAIR（多启动与单次）
```text
  |  cand ← ROUND_AND_REPAIR_MULTI(G, x*, y*, K, restarts, perturb_y)  
  |  // 作用：从 LP 的分数解 x*, y* 出发，做多次“舍入+修补”尝试（Multi-Start），
  |  //      希望在至多 K 种颜色内得到一个整数可行染色 cand。
  |  // 变量含义：
  |  //   G         ：输入图。
  |  //   x*        ：LP分数解的顶点-颜色倾向（x*[v,c]∈[0,1]；数值大→LP更“希望”v用色c）。
  |  //   y*        ：LP分数解的颜色启用强度（y*[c]∈[0,1]；数值大→颜色c更“活跃/被使用”）。
  |  //   K         ：当前的上界（UB），目标是在 ≤K 的颜色预算内找到整数解。
  |  //   restarts  ：重启次数，多次独立尝试以提高成功率/质量。
  |  //   perturb_y ：给 y* 加极小噪声的幅度（störung），避免一成不变的排序。

Function ROUND_AND_REPAIR_MULTI(G, x*, y*, current_UB, restarts, seed, perturb_y)
  best <- None                                    // 当前找到的“最好可行解”（以用色数最少为主）
  rnd <- init_rnd(seed)                           // 随机数生成器，按 seed 固定，保证复现

  for r in 1..restarts do                         // Multi-Start：做 restarts 次独立尝试
    yj <- ADD_TINY_NOISE，用（y*, scale=perturb_y(float:1e-6), rnd=rnd）3个参数来构造,这里需要对所有c的y*值进行构造生成yj
    // yj：在 y* 基础上加极小随机扰动（幅度由 perturb_y 控制）；
    //   目的是打破 y* 的排序平局，让每次 r 的颜色优先顺序略有差别。

    cand <- ROUND_AND_REPAIR(G, x*, yj, current_UB, rnd)
    // 调用一次“舍入+修补”：尝试在 ≤current_UB 颜色内，把分数解变成整数可行染色。

      best <- cand
      // 若 cand 可行且用色数更少，则更新 best。

  return (best if best≠None else infeasible)
  // 所有尝试都失败 → 返回不可行标记；否则返回最优的可行解 best
End

Function ROUND_AND_REPAIR(G, x*, yj, current_UB, rnd)
  order_colors <- 根据yj进行排序,yj越大越应该优先(descending)
  // 给颜色一个顺序。理由：
  //  - y* 越“启用”，越应该优先尝试
  // 结果：形成一个例如 [色0, 色1, 色2, ...] 的尝试优先级。

  order_vertices <- 对所有点进行排序
  // 这里所有未着色的点按照3个优先级进行排序:
  //1. 高饱和度优先，（饱和度:某个尚未上色的顶点，其已上色邻居所使用的“不同颜色的种类数”），越困难越要排在最前面，或许可以减少犯错的机会
  //2. 如果饱和度相同，度数大的点优先（度数：邻居数量）
  //3. 如果饱和度、度数都相同，比较该点在颜色域 0..K-1 上的 x* 最大值,不先过滤与邻居冲突的颜色。（这说明我之前得到的LP更“希望”给这个点某个颜色，应该作为优先级更高的顺序）。
  //4. 如果前面所有的情况都相同，那么这个时候考虑加入1e-9的random扰动，完全考虑随机性。
  
  init coloring <- EMPTY


  for v in order_vertices do
    cand_colors <- 筛选可用颜色，根据(v, coloring, order_colors)
    // 在“颜色优先级”顺序下，筛出“不与邻居冲突”的颜色列表。
    // 理由：合法性第一位；只在可用色里挑。

    prefer <- 选择 argmax_c x*[v,c] over cand_colors
    // 在“对 v 合法的颜色”集合 cand_colors 里，挑一个让 LP 分数 x*[v,c] 最大的颜色 c 作为 v 的首选。
    //因为目的是把一个“分数解”往“整数解”靠拢；在不制造冲突的前提下，尽量沿着 LP 最偏好的方向取整

    if prefer exists then
      ASSIGN(v, prefer)
      // 能按 LP 倾向赋色就直接赋。尽量尊重 LP，通常更接近最优。

    else
      if TRY_KEMPE_CHAIN_MOVE(G, coloring, v, order_colors) then
        continue
        // 没有可用色（所有候选都与邻居冲突）→ 尝试 Kempe 链交换:
        // 函数TRY_KEMPE_CHAIN_MOVE()：
        // 在两种颜色 a/b 的“交替链”上做整体交换，把某个邻居从 a→b，
        // 再把另一个从 b→a，最终为 v 腾出一种颜色。
        // 成功就继续下一个点。

      else
        直接把 argmax_c x*[v,c] 的颜色放上去（哪怕会临时产生冲突），把问题留给后面的修补阶段。
        

  coloring <- SMALL_REPAIR_PASSES(G, coloring, passes=2..3)
  //coloring是“当前的着色解”，一个 v -> color 的字典。
  //passes指“本地修补/压色的外层循环次数”
  // 小规模本地修补（选择度数更高的点，先尝试空闲的颜色，按照y_frac优先级，再尝试Kempe，如果依然不行就rollback），
  // 目的是清理遗留的低强度冲突或多余色，

  feasible <- CHECK NO CONFLICTS
  // 最后检查：没有邻接同色、颜色不越界。

  return (coloring if feasible else INFEASIBLE)
  // 可行就交给外层比较 UB；否则告诉外层“这次尝试失败”，让它换别的重启或侧向。
End

```

---

# 三个加速器（Side/Pack/Greedy）

```text
Function TRY_SIDE_ROUNDING(G, x*, y*, target_UB, restarts, perturb_y)
  cand ← ROUND_AND_REPAIR_MULTI(G, x*, y*, K=target_UB, restarts, perturb_y)  
  // 把“允许颜色数”当作 K 传入（虽然它叫 target_UB，但在 R&R 里就是“前缀预算”）。
  if VERIFY(G, cand, allowed=0..target_UB-1) == feasible then
    return (True, CONSOLIDATE_COLORS(G, COMPACT(cand)))  
    // 返回压紧后的可行解；让调用者判断是否优于当前 UB。
  else
    return (False, None)  
    // 不可行就放弃这条侧向分支，避免浪费迭代时间。
End


Function TRY_LP_GUIDED_PACK(G, best, x*, K, UB)
  if UB ≠ K+1 then return (False, None)  
  // 只在“差 1 色”的窗口启用；否则收益/成本比不划算。

  S ← vertices with color = UB-1 in best  
  // 最高颜色层的顶点集合；目标是把它们塞回 0..K-1。

  order S by preference from x* (desc)  
  // 先移动“x* 强烈偏好某个低色”的点，成功率高且副作用小。

  for v in S do
    try place v into prefix 0..K-1 using greedy + small local moves  
    // 先贪心放置；冲突时少量局部变换（如 Kempe），但限制步数，避免过度搜索。

  if all moved then
    return (True, COMPACT(best_after_moves))  
    // 如果最高色被清空，说明成功把 UB 减 1。
  else
    return (False, None)  
    // 没清空就不算“打包成功”；由上层再考虑其他策略。
End


Function TRY_GRAPH_UB1_GREEDY(G, best, UB)
  attempt ← greedy + limited Kempe to fit colors into 0..UB-2  
  // 完全在图域操作：不看 LP，只用贪心/链交换尝试把所有点装进 UB-1 个颜色。
  if success then return (True, COMPACT(attempt)) else return (False, None)
  // 成功就返回可行的 UB-1 解；失败说明纯图域也暂时不行。
End

```

---

# 固定策略（PICK_FIXINGS）

```text
Function PICK_FIXINGS(x*, y*, zLP, UB, LB, policy, max_fix_per_round, support_from_round)
  plan.x_one ← ∅  
  // 我们只启用“把 x[v,c]=1 的正向固定”；y_zero 由 LOCK_PREFIX 统一处理，更安全。

  if "prefix_shrink" in policy then
    K_hint ← max(LB, ceil(zLP))  
    // 由 LP 下界提示“可关闭的后缀颜色”；但真正关闭在 LOCK_PREFIX 执行，保持职责单一。

  if "rounded_support" in policy and support_from_round ≠ None then
    // 只固定“LP 倾向与最新舍入一致”的点，减少与 LP/舍入的分歧（防抖）。
    candidates ← { v | argmax_c x*[v,c] == support_from_round[v] and x*[v,that] ≥ 0.8 }
    // 0.8 是经验阈值：越高越保守，越低越冒进；目的：先固定“明显正确”的点。
    plan.x_one ← take up to max_fix_per_round from candidates, highest x* first
    // 限额是为了避免一次固定太多把模型锁死，循序渐进更稳。

  return plan  
  // 交给上层用 FIX_X_ON 应用（带回滚保护）。
End

```

---

# 验证与可视化（VERIFY / VIZ）

```text
Function VERIFY(G, coloring, allowed)
  if coloring == None then return {feasible:False, reason:"empty"}
  if EXISTS v with coloring[v] ∉ allowed then
    return {feasible:False, reason:"color_out_of_range"}
  for each edge (u,v) in E(G) do
    if coloring[u] == coloring[v] then
      return {feasible:False, reason:"conflict", edge:(u,v)}
  return {feasible:True, reason:"ok"}
End

Function VIZ(enabled, tag, round_id, coloring, K_or_UB)
  if not enabled then return                                // 可视化可被关闭
  IMG <- DRAW_PARTIAL_COLORING(G, coloring, highlight_conflicts=True,
                               title=f"{tag} r{round_id} K={K_or_UB}")
  SAVE_IMAGE(IMG, dir=viz_out_dir, name=f"{tag}-{round_id}.png")
End
```

---

# 常用小工具（紧凑化/合并/枚举）

```text
Function COMPACT_COLORS(coloring)
  remap <- BUILD_ORDERED_MAP(sorted(unique(coloring.values()))) // 建立颜色重映射表
  for v in VERTICES(G) do coloring[v] <- remap[coloring[v]]     // 颜色编号紧凑为 0..k-1
  return (coloring, |remap|)                                   // 返回新解与用色数
End

Function CONSOLIDATE_COLORS(G, coloring, passes)
  changed <- False
  repeat passes times:
    for c from HIGHEST_COLOR down to 1 do                      // 从高色往低色尝试塞回
      S <- {v | coloring[v]=c}
      if TRY_MOVE_SET_TO_PREFIX(G, S, allowed_colors=0..c-1)   // 贪心+少量 Kempe
        ERASE_COLOR(c); changed <- True
  return (coloring, changed)
End

Function ENUM_TOP_MAXIMAL_CLIQUES(G, cap, min_size, time_cap)
  C <- []
  TIMER_START()
  for each seed v in VERTICES(G) with heuristic order do
    Q <- EXPAND_MAXIMAL_CLIQUE(G, start=v)                      // BK 或启发式增长
    if |Q| >= min_size then APPEND(C, Q)
    if |C| >= cap or TIMER_ELAPSED() >= time_cap then break
  return C
End
```
---
